; SMT-LIBv2 description generated by firrtl 1.4-SNAPSHOT for module Adder.
(set-logic QF_UFBV)
(set-option :produce-models true)

(declare-sort Adder_s 0)
; firrtl-smt2-input reset 1
(declare-fun reset_f (Adder_s) Bool)
; firrtl-smt2-input io_a 8
(declare-fun io_a_f (Adder_s) (_ BitVec 8))
; firrtl-smt2-input io_b 8
(declare-fun io_b_f (Adder_s) (_ BitVec 8))
; firrtl-smt2-wire _T 1
; @ CaseStudy.scala 33:16
(define-fun _T_f ((state_0 Adder_s)) Bool 
	(not 
		(= 
			(io_a_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire _T_1 1
; @ CaseStudy.scala 33:32
(define-fun _T_1_f ((state_0 Adder_s)) Bool 
	(not 
		(= 
			(io_b_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire _T_2 1
; @ CaseStudy.scala 33:24
(define-fun _T_2_f ((state_0 Adder_s)) Bool 
	(and 
		(_T_f state_0) 
		(_T_1_f state_0)))
; firrtl-smt2-wire _T_3 9
; @ CaseStudy.scala 34:18
(define-fun _T_3_f ((state_0 Adder_s)) (_ BitVec 9) 
	(bvadd 
		((_ zero_extend 1) 
			(io_a_f state_0)) 
		((_ zero_extend 1) 
			(io_b_f state_0))))
; firrtl-smt2-wire _T_4 8
; @ CaseStudy.scala 34:18
(define-fun _T_4_f ((state_0 Adder_s)) (_ BitVec 8) 
	((_ extract 7 0) 
		(_T_3_f state_0)))
; firrtl-smt2-wire _T_5 9
; @ CaseStudy.scala 35:26
(define-fun _T_5_f ((state_0 Adder_s)) (_ BitVec 9) 
	(bvadd 
		((_ zero_extend 1) 
			(io_a_f state_0)) 
		((_ zero_extend 1) 
			(io_b_f state_0))))
; firrtl-smt2-wire _T_6 8
; @ CaseStudy.scala 35:26
(define-fun _T_6_f ((state_0 Adder_s)) (_ BitVec 8) 
	((_ extract 7 0) 
		(_T_5_f state_0)))
; firrtl-smt2-output io_out 8
; @ CaseStudy.scala 34:10
(define-fun io_out_f ((state_0 Adder_s)) (_ BitVec 8) 
	(_T_4_f state_0))
; firrtl-smt2-wire _T_7 1
; @ CaseStudy.scala 35:17
(define-fun _T_7_f ((state_0 Adder_s)) Bool 
	(= 
		(io_out_f state_0) 
		(_T_6_f state_0)))
; firrtl-smt2-assume assume_0 1
; @ CaseStudy.scala 33:10
(define-fun assume_0_f ((state_0 Adder_s)) Bool 
	(_T_2_f state_0))
; firrtl-smt2-assert assert_combinatorial_0 1
; @ CaseStudy.scala 35:9
(define-fun assert_combinatorial_0_f ((state_0 Adder_s)) Bool 
	(_T_7_f state_0))
; This function evaluates to ’true’ if the states ’state’ and
; ’next_state’ form a valid state transition."
(define-fun Adder_t ((state Adder_s) (state_n Adder_s)) Bool 
	true)
; This function must be asserted ’true’ for initial states. For
; non-initial states it must be left unconstrained.
(define-fun Adder_i ((state_0 Adder_s)) Bool 
	true)
; This function evaluates to ’true’ if all assertions hold in the state.
(define-fun Adder_a ((state_0 Adder_s)) Bool 
	(and 
		(assume_0_f state_0) 
		(assert_combinatorial_0_f state_0)))
; This function evaluates to ’true’ if all assumptions hold in the state.
(define-fun Adder_u ((state_0 Adder_s)) Bool 
	(assume_0_f state_0))


;  Combinatorial 
(push 1)
(declare-fun assert_combinatorial_0 () Adder_s)
(assert 
	(Adder_u assert_combinatorial_0))
(assert 
	(not 
		(reset_f assert_combinatorial_0)))
; Assume the dependencies
(assert 
	(not 
		(assert_combinatorial_0_f assert_combinatorial_0)))
(echo "Checking assert_combinatorial_0")
(check-sat)
(get-value ((io_a_f assert_combinatorial_0)))
(get-value ((io_b_f assert_combinatorial_0)))
(pop 1)


