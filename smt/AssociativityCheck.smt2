; SMT-LIBv2 description generated by firrtl 1.4-SNAPSHOT for module AssociativityCheck.
(set-logic QF_UFBV)
(set-option :produce-models true)

(declare-sort AssociativityCheck_s 0)
; firrtl-smt2-input reset 1
(declare-fun reset_f (AssociativityCheck_s) Bool)
; firrtl-smt2-input io_in1 16
(declare-fun io_in1_f (AssociativityCheck_s) (_ BitVec 16))
; firrtl-smt2-input io_in2 16
(declare-fun io_in2_f (AssociativityCheck_s) (_ BitVec 16))
; firrtl-smt2-input io_in3 16
(declare-fun io_in3_f (AssociativityCheck_s) (_ BitVec 16))
; firrtl-smt2-input op1.io_out 16
; @ AssociativityCheck.scala 33:19
(declare-fun op1.io_out_f (AssociativityCheck_s) (_ BitVec 16))
; firrtl-smt2-input op2.io_out 16
; @ AssociativityCheck.scala 34:19
(declare-fun op2.io_out_f (AssociativityCheck_s) (_ BitVec 16))
; firrtl-smt2-input op3.io_out 16
; @ AssociativityCheck.scala 36:19
(declare-fun op3.io_out_f (AssociativityCheck_s) (_ BitVec 16))
; firrtl-smt2-input op4.io_out 16
; @ AssociativityCheck.scala 37:19
(declare-fun op4.io_out_f (AssociativityCheck_s) (_ BitVec 16))
; firrtl-smt2-wire _T 1
; @ AssociativityCheck.scala 53:21
(define-fun _T_f ((state_0 AssociativityCheck_s)) Bool 
	(= 
		(op2.io_out_f state_0) 
		(op4.io_out_f state_0)))
; firrtl-smt2-output op1.reset 1
; @ AssociativityCheck.scala 33:19
(define-fun op1.reset_f ((state_0 AssociativityCheck_s)) Bool 
	(reset_f state_0))
; firrtl-smt2-output op1.io_in1 16
; @ AssociativityCheck.scala 33:19, AssociativityCheck.scala 40:14
(define-fun op1.io_in1_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(io_in1_f state_0))
; firrtl-smt2-output op1.io_in2 16
; @ AssociativityCheck.scala 33:19, AssociativityCheck.scala 41:14
(define-fun op1.io_in2_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(io_in2_f state_0))
; firrtl-smt2-output op2.reset 1
; @ AssociativityCheck.scala 34:19
(define-fun op2.reset_f ((state_0 AssociativityCheck_s)) Bool 
	(reset_f state_0))
; firrtl-smt2-output op2.io_in1 16
; @ AssociativityCheck.scala 34:19, AssociativityCheck.scala 43:14
(define-fun op2.io_in1_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(op1.io_out_f state_0))
; firrtl-smt2-output op2.io_in2 16
; @ AssociativityCheck.scala 34:19, AssociativityCheck.scala 44:14
(define-fun op2.io_in2_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(io_in3_f state_0))
; firrtl-smt2-output op3.reset 1
; @ AssociativityCheck.scala 36:19
(define-fun op3.reset_f ((state_0 AssociativityCheck_s)) Bool 
	(reset_f state_0))
; firrtl-smt2-output op3.io_in1 16
; @ AssociativityCheck.scala 36:19, AssociativityCheck.scala 47:14
(define-fun op3.io_in1_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(io_in2_f state_0))
; firrtl-smt2-output op3.io_in2 16
; @ AssociativityCheck.scala 36:19, AssociativityCheck.scala 48:14
(define-fun op3.io_in2_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(io_in3_f state_0))
; firrtl-smt2-output op4.reset 1
; @ AssociativityCheck.scala 37:19
(define-fun op4.reset_f ((state_0 AssociativityCheck_s)) Bool 
	(reset_f state_0))
; firrtl-smt2-output op4.io_in1 16
; @ AssociativityCheck.scala 37:19, AssociativityCheck.scala 50:14
(define-fun op4.io_in1_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(io_in1_f state_0))
; firrtl-smt2-output op4.io_in2 16
; @ AssociativityCheck.scala 37:19, AssociativityCheck.scala 51:14
(define-fun op4.io_in2_f ((state_0 AssociativityCheck_s)) (_ BitVec 16) 
	(op3.io_out_f state_0))
; firrtl-smt2-assert assert_combinatorial_0 1
; @ AssociativityCheck.scala 53:9
(define-fun assert_combinatorial_0_f ((state_0 AssociativityCheck_s)) Bool 
	(_T_f state_0))
; This function evaluates to ’true’ if the states ’state’ and
; ’next_state’ form a valid state transition."
(define-fun AssociativityCheck_t ((state AssociativityCheck_s) (state_n AssociativityCheck_s)) Bool 
	true)
; This function must be asserted ’true’ for initial states. For
; non-initial states it must be left unconstrained.
(define-fun AssociativityCheck_i ((state_0 AssociativityCheck_s)) Bool 
	true)
; This function evaluates to ’true’ if all assertions hold in the state.
(define-fun AssociativityCheck_a ((state_0 AssociativityCheck_s)) Bool 
	(assert_combinatorial_0_f state_0))
; This function evaluates to ’true’ if all assumptions hold in the state.
(define-fun AssociativityCheck_u ((state_0 AssociativityCheck_s)) Bool 
	true)


;  Combinatorial 
(push 1)
(declare-fun assert_combinatorial_0 () AssociativityCheck_s)
(assert 
	(AssociativityCheck_u assert_combinatorial_0))
(assert 
	(not 
		(reset_f assert_combinatorial_0)))
; Assume the dependencies
(assert 
	(not 
		(assert_combinatorial_0_f assert_combinatorial_0)))
(echo "Checking assert_combinatorial_0")
(check-sat)
(get-value ((op2.io_out_f assert_combinatorial_0)))
(get-value ((op4.io_out_f assert_combinatorial_0)))
(pop 1)


