; SMT-LIBv2 description generated by firrtl 1.4-SNAPSHOT for module Induction.
(set-logic QF_UFBV)
(set-option :produce-models true)

(declare-sort Induction_s 0)
; firrtl-smt2-input reset 1
(declare-fun reset_f (Induction_s) Bool)
; firrtl-smt2-input io_in 1
(declare-fun io_in_f (Induction_s) Bool)
; firrtl-smt2-register reg1 4
; @ InductionTest.scala 13:21, InductionTest.scala 13:21, InductionTest.scala 13:21, InductionTest.scala 16:8
(declare-fun reg1_f (Induction_s) (_ BitVec 4))
; firrtl-smt2-register reg2 4
; @ InductionTest.scala 14:21, InductionTest.scala 14:21, InductionTest.scala 14:21, InductionTest.scala 17:8
(declare-fun reg2_f (Induction_s) (_ BitVec 4))
; firrtl-smt2-wire _T 5
; @ InductionTest.scala 16:17
(define-fun _T_f ((state_0 Induction_s)) (_ BitVec 5) 
	(concat 
		(reg1_f state_0) (ite 
		false (_ bv1 1) (_ bv0 1))))
; firrtl-smt2-wire _T_1 5
; @ InductionTest.scala 16:23
(define-fun _T_1_f ((state_0 Induction_s)) (_ BitVec 5) 
	(bvor 
		(_T_f state_0) 
		((_ zero_extend 4) (ite 
			(io_in_f state_0) (_ bv1 1) (_ bv0 1)))))
; firrtl-smt2-wire _T_2 5
; @ InductionTest.scala 17:17
(define-fun _T_2_f ((state_0 Induction_s)) (_ BitVec 5) 
	(concat 
		(reg2_f state_0) (ite 
		false (_ bv1 1) (_ bv0 1))))
; firrtl-smt2-wire _T_3 5
; @ InductionTest.scala 17:23
(define-fun _T_3_f ((state_0 Induction_s)) (_ BitVec 5) 
	(bvor 
		(_T_2_f state_0) 
		((_ zero_extend 4) (ite 
			(io_in_f state_0) (_ bv1 1) (_ bv0 1)))))
; firrtl-smt2-wire _T_4 1
; @ InductionTest.scala 19:17
(define-fun _T_4_f ((state_0 Induction_s)) Bool 
	(= ((_ extract 3 3) 
		(reg1_f state_0)) (_ bv1 1)))
; firrtl-smt2-wire _T_5 1
; @ InductionTest.scala 19:27
(define-fun _T_5_f ((state_0 Induction_s)) Bool 
	(= ((_ extract 3 3) 
		(reg2_f state_0)) (_ bv1 1)))
; firrtl-smt2-wire _T_6 1
; @ InductionTest.scala 19:21
(define-fun _T_6_f ((state_0 Induction_s)) Bool 
	(xor 
		(_T_4_f state_0) 
		(_T_5_f state_0)))
; firrtl-smt2-wire _T_7 1
; @ InductionTest.scala 21:15
(define-fun _T_7_f ((state_0 Induction_s)) Bool 
	(= 
		(reg1_f state_0) 
		(reg2_f state_0)))
; firrtl-smt2-output io_out 1
; @ InductionTest.scala 19:10
(define-fun io_out_f ((state_0 Induction_s)) Bool 
	(_T_6_f state_0))
; firrtl-smt2-assert assert_memoryInduction_0 1
; @ InductionTest.scala 21:9
(define-fun assert_memoryInduction_0_f ((state_0 Induction_s)) Bool 
	(_T_7_f state_0))
(define-fun reg1_next ((state_0 Induction_s)) (_ BitVec 4) 
	(ite 
		(reset_f state_0) 
		(_ bv0 4) 
		((_ extract 3 0) 
			(_T_1_f state_0))))
(define-fun reg2_next ((state_0 Induction_s)) (_ BitVec 4) 
	(ite 
		(reset_f state_0) 
		(_ bv0 4) 
		((_ extract 3 0) 
			(_T_3_f state_0))))
; This function evaluates to ’true’ if the states ’state’ and
; ’next_state’ form a valid state transition."
(define-fun Induction_t ((state Induction_s) (state_n Induction_s)) Bool 
	(and 
		(= 
			(reg1_f state_n) 
			(reg1_next state)) 
		(= 
			(reg2_f state_n) 
			(reg2_next state))))
; This function must be asserted ’true’ for initial states. For
; non-initial states it must be left unconstrained.
(define-fun Induction_i ((state_0 Induction_s)) Bool 
	true)
; This function evaluates to ’true’ if all assertions hold in the state.
(define-fun Induction_a ((state_0 Induction_s)) Bool 
	(assert_memoryInduction_0_f state_0))
; This function evaluates to ’true’ if all assumptions hold in the state.
(define-fun Induction_u ((state_0 Induction_s)) Bool 
	true)
; 
;  Induction : Initial state of memory (state after reset holds) holds assertion
;            : P(s) => p(next(s)) if s => next(s) is a valid transition 
; 
; base case
(push 1)
(declare-fun assert_memoryInduction_0_init () Induction_s)
(declare-fun assert_memoryInduction_0_next_init () Induction_s)
(assert 
	(reset_f assert_memoryInduction_0_init))
(assert 
	(Induction_t assert_memoryInduction_0_init assert_memoryInduction_0_next_init))
(assert 
	(not 
		(assert_memoryInduction_0_f assert_memoryInduction_0_next_init)))
(echo "Checking assert_memoryInduction_0 on the base case")
(check-sat)
(get-value ((reg1_f assert_memoryInduction_0_init) (reg1_f assert_memoryInduction_0_next_init)))
(get-value ((reg2_f assert_memoryInduction_0_init) (reg2_f assert_memoryInduction_0_next_init)))
(pop 1)
; 
; inductive case
(push 1)
(declare-fun assert_memoryInduction_0_valid () Induction_s)
(declare-fun assert_memoryInduction_0_next_valid () Induction_s)
(assert 
	(assert_memoryInduction_0_f assert_memoryInduction_0_valid))
(assert 
	(Induction_t assert_memoryInduction_0_valid assert_memoryInduction_0_next_valid))
(assert 
	(not 
		(assert_memoryInduction_0_f assert_memoryInduction_0_next_valid)))
(echo "Checking assert_memoryInduction_0 on the inductive")
(check-sat)
(get-value ((reg1_f assert_memoryInduction_0_valid) (reg1_f assert_memoryInduction_0_next_valid)))
(get-value ((reg2_f assert_memoryInduction_0_valid) (reg2_f assert_memoryInduction_0_next_valid)))
(pop 1)
; 
