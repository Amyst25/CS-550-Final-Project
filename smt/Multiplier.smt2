; SMT-LIBv2 description generated by firrtl 1.4-SNAPSHOT for module Multiplier.
(set-logic QF_UFBV)
(set-option :produce-models true)

(declare-sort Multiplier_s 0)
; firrtl-smt2-input reset 1
(declare-fun reset_f (Multiplier_s) Bool)
; firrtl-smt2-input io_a 8
(declare-fun io_a_f (Multiplier_s) (_ BitVec 8))
; firrtl-smt2-input io_b 8
(declare-fun io_b_f (Multiplier_s) (_ BitVec 8))
; firrtl-smt2-wire _T 1
; @ CaseStudy.scala 44:16
(define-fun _T_f ((state_0 Multiplier_s)) Bool 
	(not 
		(= 
			(io_a_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire _T_1 1
; @ CaseStudy.scala 44:32
(define-fun _T_1_f ((state_0 Multiplier_s)) Bool 
	(not 
		(= 
			(io_b_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire _T_2 1
; @ CaseStudy.scala 44:24
(define-fun _T_2_f ((state_0 Multiplier_s)) Bool 
	(and 
		(_T_f state_0) 
		(_T_1_f state_0)))
; firrtl-smt2-wire _T_3 16
; @ CaseStudy.scala 45:18
(define-fun _T_3_f ((state_0 Multiplier_s)) (_ BitVec 16) 
	(bvmul 
		((_ zero_extend 8) 
			(io_a_f state_0)) 
		((_ zero_extend 8) 
			(io_b_f state_0))))
; firrtl-smt2-wire _T_4 16
; @ CaseStudy.scala 46:26
(define-fun _T_4_f ((state_0 Multiplier_s)) (_ BitVec 16) 
	(bvmul 
		((_ zero_extend 8) 
			(io_a_f state_0)) 
		((_ zero_extend 8) 
			(io_b_f state_0))))
; firrtl-smt2-output io_out 16
; @ CaseStudy.scala 45:10
(define-fun io_out_f ((state_0 Multiplier_s)) (_ BitVec 16) 
	(_T_3_f state_0))
; firrtl-smt2-wire _T_5 1
; @ CaseStudy.scala 46:17
(define-fun _T_5_f ((state_0 Multiplier_s)) Bool 
	(= 
		(io_out_f state_0) 
		(_T_4_f state_0)))
; firrtl-smt2-assume assume_0 1
; @ CaseStudy.scala 44:10
(define-fun assume_0_f ((state_0 Multiplier_s)) Bool 
	(_T_2_f state_0))
; firrtl-smt2-assert assert_combinatorial_0 1
; @ CaseStudy.scala 46:9
(define-fun assert_combinatorial_0_f ((state_0 Multiplier_s)) Bool 
	(_T_5_f state_0))
; This function evaluates to ’true’ if the states ’state’ and
; ’next_state’ form a valid state transition."
(define-fun Multiplier_t ((state Multiplier_s) (state_n Multiplier_s)) Bool 
	true)
; This function must be asserted ’true’ for initial states. For
; non-initial states it must be left unconstrained.
(define-fun Multiplier_i ((state_0 Multiplier_s)) Bool 
	true)
; This function evaluates to ’true’ if all assertions hold in the state.
(define-fun Multiplier_a ((state_0 Multiplier_s)) Bool 
	(and 
		(assume_0_f state_0) 
		(assert_combinatorial_0_f state_0)))
; This function evaluates to ’true’ if all assumptions hold in the state.
(define-fun Multiplier_u ((state_0 Multiplier_s)) Bool 
	(assume_0_f state_0))


;  Combinatorial 
(push 1)
(declare-fun assert_combinatorial_0 () Multiplier_s)
(assert 
	(Multiplier_u assert_combinatorial_0))
(assert 
	(not 
		(reset_f assert_combinatorial_0)))
; Assume the dependencies
(assert 
	(not 
		(assert_combinatorial_0_f assert_combinatorial_0)))
(echo "Checking assert_combinatorial_0")
(check-sat)
(get-value ((io_a_f assert_combinatorial_0)))
(get-value ((io_b_f assert_combinatorial_0)))
(pop 1)


