; SMT-LIBv2 description generated by firrtl 1.4-SNAPSHOT for module MultiplyAndAdd.
(set-logic QF_UFBV)
(set-option :produce-models true)

(declare-sort MultiplyAndAdd_s 0)
; firrtl-smt2-input reset 1
(declare-fun reset_f (MultiplyAndAdd_s) Bool)
; firrtl-smt2-input io_a 8
(declare-fun io_a_f (MultiplyAndAdd_s) (_ BitVec 8))
; firrtl-smt2-input io_b 8
(declare-fun io_b_f (MultiplyAndAdd_s) (_ BitVec 8))
; firrtl-smt2-input io_c 8
(declare-fun io_c_f (MultiplyAndAdd_s) (_ BitVec 8))
; firrtl-smt2-input innerAdder.io_out 8
; @ CaseStudy.scala 16:28
(declare-fun innerAdder.io_out_f (MultiplyAndAdd_s) (_ BitVec 8))
; firrtl-smt2-input innerMultiplier.io_out 16
; @ CaseStudy.scala 20:31
(declare-fun innerMultiplier.io_out_f (MultiplyAndAdd_s) (_ BitVec 16))
; firrtl-smt2-wire _T 1
; @ CaseStudy.scala 14:16
(define-fun _T_f ((state_0 MultiplyAndAdd_s)) Bool 
	(not 
		(= 
			(io_a_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire _T_1 1
; @ CaseStudy.scala 14:32
(define-fun _T_1_f ((state_0 MultiplyAndAdd_s)) Bool 
	(not 
		(= 
			(io_b_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire _T_2 1
; @ CaseStudy.scala 14:24
(define-fun _T_2_f ((state_0 MultiplyAndAdd_s)) Bool 
	(and 
		(_T_f state_0) 
		(_T_1_f state_0)))
; firrtl-smt2-wire _T_3 1
; @ CaseStudy.scala 14:48
(define-fun _T_3_f ((state_0 MultiplyAndAdd_s)) Bool 
	(not 
		(= 
			(io_c_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire _T_4 1
; @ CaseStudy.scala 14:40
(define-fun _T_4_f ((state_0 MultiplyAndAdd_s)) Bool 
	(and 
		(_T_2_f state_0) 
		(_T_3_f state_0)))
; firrtl-smt2-wire _T_5 9
; @ CaseStudy.scala 24:27
(define-fun _T_5_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 9) 
	(bvadd 
		((_ zero_extend 1) 
			(io_a_f state_0)) 
		((_ zero_extend 1) 
			(io_b_f state_0))))
; firrtl-smt2-wire _T_6 8
; @ CaseStudy.scala 24:27
(define-fun _T_6_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 8) 
	((_ extract 7 0) 
		(_T_5_f state_0)))
; firrtl-smt2-wire _T_7 16
; @ CaseStudy.scala 24:35
(define-fun _T_7_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 16) 
	(bvmul 
		((_ zero_extend 8) 
			(_T_6_f state_0)) 
		((_ zero_extend 8) 
			(io_c_f state_0))))
; firrtl-smt2-output io_out 17
; @ CaseStudy.scala 23:10
(define-fun io_out_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 17) 
	((_ zero_extend 1) 
		(innerMultiplier.io_out_f state_0)))
; firrtl-smt2-wire _T_8 1
; @ CaseStudy.scala 24:17
(define-fun _T_8_f ((state_0 MultiplyAndAdd_s)) Bool 
	(= 
		(io_out_f state_0) 
		((_ zero_extend 1) 
			(_T_7_f state_0))))
; firrtl-smt2-wire intermediary 8
; @ CaseStudy.scala 15:26, CaseStudy.scala 19:16
(define-fun intermediary_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 8) 
	(innerAdder.io_out_f state_0))
; firrtl-smt2-wire lifted__T_5_Adder 9
; @ CaseStudy.scala 35:26
(define-fun lifted__T_5_Adder_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 9) 
	(bvadd 
		((_ zero_extend 1) 
			(io_a_f state_0)) 
		((_ zero_extend 1) 
			(io_b_f state_0))))
; firrtl-smt2-wire lifted__T_6_Adder 8
; @ CaseStudy.scala 35:26
(define-fun lifted__T_6_Adder_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 8) 
	((_ extract 7 0) 
		(lifted__T_5_Adder_f state_0)))
; firrtl-smt2-wire lifted__T_7_Adder 1
; @ CaseStudy.scala 35:17
(define-fun lifted__T_7_Adder_f ((state_0 MultiplyAndAdd_s)) Bool 
	(= 
		(intermediary_f state_0) 
		(lifted__T_6_Adder_f state_0)))
; firrtl-smt2-assume assume_0 1
; @ CaseStudy.scala 35:9
(define-fun assume_0_f ((state_0 MultiplyAndAdd_s)) Bool 
	(lifted__T_7_Adder_f state_0))
; firrtl-smt2-wire lifted__T_Adder 1
; @ CaseStudy.scala 33:16
(define-fun lifted__T_Adder_f ((state_0 MultiplyAndAdd_s)) Bool 
	(not 
		(= 
			(io_a_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire lifted__T_1_Adder 1
; @ CaseStudy.scala 33:32
(define-fun lifted__T_1_Adder_f ((state_0 MultiplyAndAdd_s)) Bool 
	(not 
		(= 
			(io_b_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire lifted__T_2_Adder 1
; @ CaseStudy.scala 33:24
(define-fun lifted__T_2_Adder_f ((state_0 MultiplyAndAdd_s)) Bool 
	(and 
		(lifted__T_Adder_f state_0) 
		(lifted__T_1_Adder_f state_0)))
; firrtl-smt2-assert assert_nonInstantiated_0 1
; @ CaseStudy.scala 33:10
(define-fun assert_nonInstantiated_0_f ((state_0 MultiplyAndAdd_s)) Bool 
	(lifted__T_2_Adder_f state_0))
; firrtl-smt2-wire lifted__T_4_Multiplier 16
; @ CaseStudy.scala 46:26
(define-fun lifted__T_4_Multiplier_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 16) 
	(bvmul 
		((_ zero_extend 8) 
			(intermediary_f state_0)) 
		((_ zero_extend 8) 
			(io_c_f state_0))))
; firrtl-smt2-wire lifted__T_5_Multiplier 1
; @ CaseStudy.scala 46:17
(define-fun lifted__T_5_Multiplier_f ((state_0 MultiplyAndAdd_s)) Bool 
	(= 
		(io_out_f state_0) 
		((_ zero_extend 1) 
			(lifted__T_4_Multiplier_f state_0))))
; firrtl-smt2-assume assume_1 1
; @ CaseStudy.scala 46:9
(define-fun assume_1_f ((state_0 MultiplyAndAdd_s)) Bool 
	(lifted__T_5_Multiplier_f state_0))
; firrtl-smt2-wire lifted__T_Multiplier 1
; @ CaseStudy.scala 44:16
(define-fun lifted__T_Multiplier_f ((state_0 MultiplyAndAdd_s)) Bool 
	(not 
		(= 
			(intermediary_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire lifted__T_1_Multiplier 1
; @ CaseStudy.scala 44:32
(define-fun lifted__T_1_Multiplier_f ((state_0 MultiplyAndAdd_s)) Bool 
	(not 
		(= 
			(io_c_f state_0) 
			(_ bv0 8))))
; firrtl-smt2-wire lifted__T_2_Multiplier 1
; @ CaseStudy.scala 44:24
(define-fun lifted__T_2_Multiplier_f ((state_0 MultiplyAndAdd_s)) Bool 
	(and 
		(lifted__T_Multiplier_f state_0) 
		(lifted__T_1_Multiplier_f state_0)))
; firrtl-smt2-assert assert_nonInstantiated_1 1
; @ CaseStudy.scala 44:10
(define-fun assert_nonInstantiated_1_f ((state_0 MultiplyAndAdd_s)) Bool 
	(lifted__T_2_Multiplier_f state_0))
; firrtl-smt2-output innerAdder.reset 1
; @ CaseStudy.scala 16:28
(define-fun innerAdder.reset_f ((state_0 MultiplyAndAdd_s)) Bool 
	(reset_f state_0))
; firrtl-smt2-output innerAdder.io_a 8
; @ CaseStudy.scala 16:28, CaseStudy.scala 17:19
(define-fun innerAdder.io_a_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 8) 
	(io_a_f state_0))
; firrtl-smt2-output innerAdder.io_b 8
; @ CaseStudy.scala 16:28, CaseStudy.scala 18:19
(define-fun innerAdder.io_b_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 8) 
	(io_b_f state_0))
; firrtl-smt2-output innerMultiplier.reset 1
; @ CaseStudy.scala 20:31
(define-fun innerMultiplier.reset_f ((state_0 MultiplyAndAdd_s)) Bool 
	(reset_f state_0))
; firrtl-smt2-output innerMultiplier.io_a 8
; @ CaseStudy.scala 20:31, CaseStudy.scala 21:24
(define-fun innerMultiplier.io_a_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 8) 
	(intermediary_f state_0))
; firrtl-smt2-output innerMultiplier.io_b 8
; @ CaseStudy.scala 20:31, CaseStudy.scala 22:24
(define-fun innerMultiplier.io_b_f ((state_0 MultiplyAndAdd_s)) (_ BitVec 8) 
	(io_c_f state_0))
; firrtl-smt2-assume assume_2 1
; @ CaseStudy.scala 14:10
(define-fun assume_2_f ((state_0 MultiplyAndAdd_s)) Bool 
	(_T_4_f state_0))
; firrtl-smt2-assert assert_combinatorial_2 1
; @ CaseStudy.scala 24:9
(define-fun assert_combinatorial_2_f ((state_0 MultiplyAndAdd_s)) Bool 
	(_T_8_f state_0))
; This function evaluates to ’true’ if the states ’state’ and
; ’next_state’ form a valid state transition."
(define-fun MultiplyAndAdd_t ((state MultiplyAndAdd_s) (state_n MultiplyAndAdd_s)) Bool 
	true)
; This function must be asserted ’true’ for initial states. For
; non-initial states it must be left unconstrained.
(define-fun MultiplyAndAdd_i ((state_0 MultiplyAndAdd_s)) Bool 
	true)
; This function evaluates to ’true’ if all assertions hold in the state.
(define-fun MultiplyAndAdd_a ((state_0 MultiplyAndAdd_s)) Bool 
	(and 
		(and 
			(and 
				(and 
					(and 
						(assume_0_f state_0) 
						(assert_nonInstantiated_0_f state_0)) 
					(assume_1_f state_0)) 
				(assert_nonInstantiated_1_f state_0)) 
			(assume_2_f state_0)) 
		(assert_combinatorial_2_f state_0)))
; This function evaluates to ’true’ if all assumptions hold in the state.
(define-fun MultiplyAndAdd_u ((state_0 MultiplyAndAdd_s)) Bool 
	(and 
		(and 
			(assume_0_f state_0) 
			(assume_1_f state_0)) 
		(assume_2_f state_0)))


;  Combinatorial 
(push 1)
(declare-fun assert_combinatorial_2 () MultiplyAndAdd_s)
(assert 
	(MultiplyAndAdd_u assert_combinatorial_2))
(assert 
	(not 
		(reset_f assert_combinatorial_2)))
; Assume the dependencies
(assert 
	(not 
		(assert_combinatorial_2_f assert_combinatorial_2)))
(echo "Checking assert_combinatorial_2")
(check-sat)
(get-value ((io_a_f assert_combinatorial_2)))
(get-value ((io_b_f assert_combinatorial_2)))
(get-value ((io_c_f assert_combinatorial_2)))
(get-value ((innerMultiplier.io_out_f assert_combinatorial_2)))
(pop 1)


